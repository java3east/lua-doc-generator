<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/de/fb/ldg/DocGenerator.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/de/fb/ldg/DocGenerator.java" />
              <option name="originalContent" value="package de.fb.ldg;&#10;&#10;import java.io.IOException;&#10;import java.nio.file.Files;&#10;import java.nio.file.Path;&#10;import java.nio.file.Paths;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.regex.Matcher;&#10;import java.util.regex.Pattern;&#10;&#10;public class DocGenerator {&#10;&#10;    private static class DocBlock {&#10;        boolean hadContent = false;&#10;        boolean expectFunction = false;&#10;        boolean hasClassOrFieldTags = false;&#10;        boolean hasTypeTag = false; // Für @type Annotations&#10;&#10;        List&lt;String&gt; lines = new ArrayList&lt;&gt;();&#10;        String description = &quot;&quot;;&#10;        List&lt;String&gt; examples = new ArrayList&lt;&gt;(); // Code-Beispiele&#10;        List&lt;SeeReference&gt; seeReferences = new ArrayList&lt;&gt;(); // @see Referenzen&#10;        String className = &quot;&quot;;&#10;        List&lt;String&gt; classParents = new ArrayList&lt;&gt;();&#10;        List&lt;Field&gt; fields = new ArrayList&lt;&gt;();&#10;        String functionName = &quot;&quot;;&#10;        String functionClassName = &quot;&quot;; // Klasse zu der die Funktion gehört&#10;        boolean isStatic = false; // Ob die Funktion statisch ist&#10;        List&lt;Function.Parameter&gt; parameters = new ArrayList&lt;&gt;();&#10;        String returnType = &quot;&quot;;&#10;        String returnDescription = &quot;&quot;;&#10;        boolean nodiscard = false;&#10;&#10;        // Variable-spezifische Felder&#10;        String variableName = &quot;&quot;;&#10;        String variableType = &quot;&quot;;&#10;        String variableDescription = &quot;&quot;;&#10;        boolean isLocalVariable = false;&#10;&#10;        boolean inCodeBlock = false; // Ob wir uns in einem Codeblock befinden (zwischen ```)&#10;&#10;        @Override&#10;        public String toString() {&#10;            StringBuilder sb = new StringBuilder();&#10;            sb.append(&quot;[BLOCK_TYPE=&quot;).append(hasClassOrFieldTags ? &quot;CLASS&quot; : &quot;FUNCTION&quot;).append(&quot;]\n&quot;);&#10;            for (String line : lines) {&#10;                sb.append(line).append(&quot;\n&quot;);&#10;            }&#10;            return sb.toString();&#10;        }&#10;    }&#10;&#10;    public static Documentation generate(String content) {&#10;        Documentation documentation = new Documentation();&#10;        List&lt;DocBlock&gt; blocks = new ArrayList&lt;&gt;();&#10;        DocBlock block = new DocBlock();&#10;&#10;        int lineNumber = 1;&#10;        String[] lines = content.split(&quot;\n&quot;);&#10;        for (int i = 0; i &lt; lines.length; i++) {&#10;            String line = lines[i];&#10;&#10;            if (isDocLine(line)) {&#10;                processDocLine(line, block);&#10;                block.lines.add(line);&#10;            } else if (block.hadContent) {&#10;                processCodeLine(line, block, lineNumber);&#10;                blocks.add(block);&#10;                block = new DocBlock();&#10;            }&#10;&#10;            lineNumber++;&#10;        }&#10;&#10;        // Zuerst alle Klassen sammeln&#10;        for (DocBlock b : blocks) {&#10;            if (b.hasClassOrFieldTags) {&#10;                processClassBlock(b, documentation);&#10;            }&#10;        }&#10;&#10;        // Dann Funktionen verarbeiten und den Klassen zuordnen&#10;        for (DocBlock b : blocks) {&#10;            if (b.expectFunction) {&#10;                processFunctionBlock(b, documentation);&#10;            }&#10;        }&#10;&#10;        // Dann Variablen verarbeiten - dabei auch Felder zu Klassen zuordnen&#10;        for (DocBlock b : blocks) {&#10;            if (b.hasTypeTag) {&#10;                processVariableBlock(b, documentation);&#10;            }&#10;        }&#10;&#10;        // Zusätzlich: Standalone @field Blöcke verarbeiten&#10;        processStandaloneFields(blocks, documentation);&#10;&#10;        return documentation;&#10;    }&#10;&#10;    private static void processClassBlock(DocBlock block, Documentation documentation) {&#10;        if (!block.className.isEmpty()) {&#10;            // Debug output to see what's happening&#10;            System.out.println(&quot;Processing class: &quot; + block.className + &quot; with &quot; + block.fields.size() + &quot; fields&quot;);&#10;            for (Field field : block.fields) {&#10;                System.out.println(&quot;  Field: &quot; + field.name + &quot; (&quot; + field.type + &quot;)&quot;);&#10;            }&#10;&#10;            // Create class with fields from the same block and see references&#10;            Class clazz = new Class(block.className, block.classParents, new ArrayList&lt;&gt;(block.fields), new ArrayList&lt;&gt;(), block.seeReferences);&#10;            documentation.addClass(clazz);&#10;        }&#10;    }&#10;&#10;    private static void processFunctionBlock(DocBlock block, Documentation documentation) {&#10;        if (!block.functionName.isEmpty()) {&#10;            // Skip local functions - they are not part of the public API&#10;            if (isLocalFunction(block)) {&#10;                return;&#10;            }&#10;&#10;            Function function = new Function(&#10;                block.functionName,&#10;                block.description,&#10;                block.parameters,&#10;                block.returnType,&#10;                block.returnDescription,&#10;                block.nodiscard,&#10;                block.isStatic,&#10;                block.examples,&#10;                block.seeReferences&#10;            );&#10;&#10;            // Prüfen, ob die Funktion zu einer Klasse gehört&#10;            if (!block.functionClassName.isEmpty()) {&#10;                // Funktion zur entsprechenden Klasse hinzufügen&#10;                Class targetClass = findClassByName(documentation, block.functionClassName);&#10;                if (targetClass != null) {&#10;                    targetClass.functions.add(function);&#10;                } else {&#10;                    // Wenn Klasse nicht gefunden, als standalone Funktion hinzufügen&#10;                    documentation.addFunction(function);&#10;                }&#10;            } else {&#10;                // Standalone Funktion&#10;                documentation.addFunction(function);&#10;            }&#10;        }&#10;    }&#10;&#10;    private static void processVariableBlock(DocBlock block, Documentation documentation) {&#10;        if (!block.variableName.isEmpty()) {&#10;            // Skip local variables - they are not part of the public API&#10;            if (block.isLocalVariable) {&#10;                return;&#10;            }&#10;&#10;            // Check if this variable name matches a class name (for nested classes)&#10;            // If we have a @class tag and the variable name matches, don't process as variable&#10;            if (!block.className.isEmpty() &amp;&amp; block.variableName.equals(block.className)) {&#10;                // This is a class assignment, not a variable - skip it&#10;                return;&#10;            }&#10;&#10;            // Check if this is a class field assignment (e.g., Config.my_value)&#10;            if (block.variableName.contains(&quot;.&quot;)) {&#10;                String[] parts = block.variableName.split(&quot;\\.&quot;, 2);&#10;                String className = parts[0];&#10;                String fieldName = parts[1];&#10;&#10;                // Skip assignments to nested objects (e.g., Config.General.framework)&#10;                // These are value assignments to already defined nested classes, not field definitions&#10;                if (fieldName.contains(&quot;.&quot;)) {&#10;                    // This is a nested assignment like Config.General.framework = &quot;value&quot;&#10;                    // Skip it as it's not a field definition but a value assignment&#10;                    return;&#10;                }&#10;&#10;                // Find the class and add this as a field&#10;                Class targetClass = findClassByName(documentation, className);&#10;                if (targetClass != null) {&#10;                    // Create a field for this class property&#10;                    Field field = new Field(fieldName, block.variableType, &quot;public&quot;, block.variableDescription);&#10;                    targetClass.fields.add(field);&#10;                    return; // Don't add as global variable&#10;                }&#10;            }&#10;&#10;            Variable variable = new Variable(block.variableName, block.variableType, block.variableDescription, block.isLocalVariable);&#10;            documentation.addVariable(variable);&#10;        }&#10;    }&#10;&#10;    private static Class findClassByName(Documentation documentation, String className) {&#10;        for (Class clazz : documentation.classes) {&#10;            if (clazz.name.equals(className)) {&#10;                return clazz;&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;&#10;    private static boolean isDocLine(String line) {&#10;        return line.trim().startsWith(&quot;---&quot;);&#10;    }&#10;&#10;    private static void processDocLine(String line, DocBlock block) {&#10;        updateBlockFlags(line, block);&#10;        parseDocContent(line, block);&#10;        block.hadContent = true;&#10;    }&#10;&#10;    private static void parseDocContent(String line, DocBlock block) {&#10;        line = line.trim();&#10;&#10;        if (line.startsWith(&quot;---@class&quot;)) {&#10;            parseClassLine(line, block);&#10;        } else if (line.startsWith(&quot;---@field&quot;)) {&#10;            parseFieldLine(line, block);&#10;        } else if (line.startsWith(&quot;---@param&quot;)) {&#10;            parseParamLine(line, block);&#10;        } else if (line.startsWith(&quot;---@return&quot;)) {&#10;            parseReturnLine(line, block);&#10;        } else if (line.startsWith(&quot;---@nodiscard&quot;)) {&#10;            block.nodiscard = true;&#10;        } else if (line.startsWith(&quot;---&quot;) &amp;&amp; !line.startsWith(&quot;---@&quot;)) {&#10;            // Plain description line - check for code blocks&#10;            String desc = line.substring(3).trim();&#10;            parseDescriptionWithCodeBlocks(desc, block);&#10;        } else if (line.startsWith(&quot;---@type&quot;)) {&#10;            parseTypeLine(line, block);&#10;        } else if (line.startsWith(&quot;---@see&quot;)) {&#10;            parseSeeLine(line, block);&#10;        }&#10;    }&#10;&#10;    private static void parseDescriptionWithCodeBlocks(String desc, DocBlock block) {&#10;        // Check if this line starts or ends a code block&#10;        if (desc.startsWith(&quot;```&quot;)) {&#10;            if (block.inCodeBlock) {&#10;                // End of code block&#10;                block.inCodeBlock = false;&#10;                // Don't add the closing ``` to examples&#10;            } else {&#10;                // Start of code block&#10;                block.inCodeBlock = true;&#10;                // Don't add the opening ``` to examples&#10;            }&#10;        } else if (block.inCodeBlock) {&#10;            // We're inside a code block, add this line to examples&#10;            if (!desc.isEmpty()) {&#10;                block.examples.add(desc);&#10;            }&#10;        } else {&#10;            // Normal description line&#10;            if (!desc.isEmpty()) {&#10;                if (!block.description.isEmpty()) {&#10;                    block.description += &quot; &quot;;&#10;                }&#10;                block.description += desc;&#10;            }&#10;        }&#10;    }&#10;&#10;    private static void parseClassLine(String line, DocBlock block) {&#10;        // Pattern: ---@class ClassName : ParentClass description&#10;        // Updated to support complex parent types like Parent&lt;{field: type}&gt;&#10;        String content = line.trim().replaceFirst(&quot;^---@class\\s+&quot;, &quot;&quot;);&#10;&#10;        // Split by first whitespace to get class name&#10;        String[] firstSplit = content.split(&quot;\\s+&quot;, 2);&#10;        if (firstSplit.length == 0) return;&#10;&#10;        String classNamePart = firstSplit[0];&#10;        String remaining = firstSplit.length &gt; 1 ? firstSplit[1] : &quot;&quot;;&#10;&#10;        // Check if class name contains inheritance separator ':'&#10;        if (classNamePart.contains(&quot;:&quot;)) {&#10;            String[] classParts = classNamePart.split(&quot;:&quot;, 2);&#10;            block.className = classParts[0].trim();&#10;&#10;            // Parse the parent type (could be complex) + remaining description&#10;            String parentAndDesc = classParts[1].trim();&#10;            if (!remaining.isEmpty()) {&#10;                parentAndDesc += &quot; &quot; + remaining;&#10;            }&#10;&#10;            // Use the same parsing logic as for types to handle complex parent types&#10;            String[] parentTypeAndDesc = parseTypeAndDescription(parentAndDesc);&#10;            String parentType = parentTypeAndDesc[0];&#10;            String description = parentTypeAndDesc[1];&#10;&#10;            if (!parentType.isEmpty()) {&#10;                block.classParents.add(parentType);&#10;            }&#10;            if (!description.isEmpty()) {&#10;                block.description = description;&#10;            }&#10;        } else {&#10;            // No inheritance, check if remaining part starts with ':'&#10;            block.className = classNamePart;&#10;&#10;            if (!remaining.isEmpty() &amp;&amp; remaining.startsWith(&quot;:&quot;)) {&#10;                // Remove the ':' and parse parent type + description&#10;                String parentAndDesc = remaining.substring(1).trim();&#10;                String[] parentTypeAndDesc = parseTypeAndDescription(parentAndDesc);&#10;                String parentType = parentTypeAndDesc[0];&#10;                String description = parentTypeAndDesc[1];&#10;&#10;                if (!parentType.isEmpty()) {&#10;                    block.classParents.add(parentType);&#10;                }&#10;                if (!description.isEmpty()) {&#10;                    block.description = description;&#10;                }&#10;            } else if (!remaining.isEmpty()) {&#10;                // Just description, no inheritance&#10;                block.description = remaining;&#10;            }&#10;        }&#10;    }&#10;&#10;    private static void parseFieldLine(String line, DocBlock block) {&#10;        // Remove the @field prefix&#10;        String content = line.trim().replaceFirst(&quot;^---@field\\s+&quot;, &quot;&quot;);&#10;&#10;        // Split by first whitespace to get field name&#10;        String[] firstSplit = content.split(&quot;\\s+&quot;, 2);&#10;        if (firstSplit.length &lt; 2) return;&#10;&#10;        String fieldName = firstSplit[0];&#10;        String remaining = firstSplit[1];&#10;&#10;        // Check if field name includes visibility modifier&#10;        String visibility = &quot;public&quot;; // Default&#10;        String actualFieldName = fieldName;&#10;&#10;        if (fieldName.equals(&quot;public&quot;) || fieldName.equals(&quot;private&quot;) || fieldName.equals(&quot;protected&quot;)) {&#10;            // Visibility modifier present&#10;            String[] secondSplit = remaining.split(&quot;\\s+&quot;, 2);&#10;            if (secondSplit.length &lt; 2) return;&#10;&#10;            visibility = fieldName;&#10;            actualFieldName = secondSplit[0];&#10;            remaining = secondSplit[1];&#10;        }&#10;&#10;        // Parse type and description&#10;        String[] typeAndDesc = parseTypeAndDescription(remaining);&#10;        String fieldType = typeAndDesc[0];&#10;        String description = typeAndDesc[1];&#10;&#10;        Field field = new Field(actualFieldName, fieldType, visibility, description);&#10;        block.fields.add(field);&#10;&#10;        // Debug output&#10;        System.out.println(&quot;Parsed field: &quot; + actualFieldName + &quot; (&quot; + fieldType + &quot;) - &quot; + description);&#10;    }&#10;&#10;    private static void parseParamLine(String line, DocBlock block) {&#10;        // Pattern: ---@param paramName type description&#10;        // Updated to handle union types like 'esx'|'qb' and complex types&#10;        String content = line.trim().replaceFirst(&quot;^---@param\\s+&quot;, &quot;&quot;);&#10;&#10;        // Split by first whitespace to get parameter name&#10;        String[] firstSplit = content.split(&quot;\\s+&quot;, 2);&#10;        if (firstSplit.length &lt; 2) return;&#10;&#10;        String paramName = firstSplit[0];&#10;        String remaining = firstSplit[1];&#10;&#10;        // Parse type (can contain unions, generics, etc.)&#10;        String[] typeAndDesc = parseTypeAndDescription(remaining);&#10;        String paramType = typeAndDesc[0];&#10;        String description = typeAndDesc[1];&#10;&#10;        Function.Parameter param = new Function.Parameter(paramName, paramType, description);&#10;        block.parameters.add(param);&#10;    }&#10;&#10;    private static void parseReturnLine(String line, DocBlock block) {&#10;        // Pattern: ---@return type description&#10;        // Updated to handle union types and complex types&#10;        String content = line.trim().replaceFirst(&quot;^---@return\\s+&quot;, &quot;&quot;);&#10;&#10;        String[] typeAndDesc = parseTypeAndDescription(content);&#10;        block.returnType = typeAndDesc[0];&#10;        block.returnDescription = typeAndDesc[1];&#10;    }&#10;&#10;    private static void parseTypeLine(String line, DocBlock block) {&#10;        // Pattern: ---@type type description&#10;        // Updated to handle union types and complex types&#10;        String content = line.trim().replaceFirst(&quot;^---@type\\s+&quot;, &quot;&quot;);&#10;&#10;        String[] typeAndDesc = parseTypeAndDescription(content);&#10;        block.variableType = typeAndDesc[0];&#10;        block.variableDescription = typeAndDesc[1];&#10;        block.hasTypeTag = true;&#10;    }&#10;&#10;    private static void parseSeeLine(String line, DocBlock block) {&#10;        // Pattern: ---@see ClassName [description]&#10;        String content = line.trim().replaceFirst(&quot;^---@see\\s+&quot;, &quot;&quot;);&#10;&#10;        if (!content.isEmpty()) {&#10;            // Split by first whitespace to separate reference name from description&#10;            String[] parts = content.split(&quot;\\s+&quot;, 2);&#10;            String referenceName = parts[0];&#10;            String description = parts.length &gt; 1 ? parts[1] : &quot;&quot;;&#10;&#10;            // Determine the type of reference based on the name pattern&#10;            SeeReference.ReferenceType type = determineReferenceType(referenceName);&#10;            SeeReference ref = new SeeReference(referenceName, type, description);&#10;            block.seeReferences.add(ref);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Determines the type of a @see reference based on its name pattern.&#10;     * @param referenceName The name of the reference&#10;     * @return The determined reference type&#10;     */&#10;    private static SeeReference.ReferenceType determineReferenceType(String referenceName) {&#10;        // If it contains a dot, it's likely a method (ClassName.methodName)&#10;        if (referenceName.contains(&quot;.&quot;)) {&#10;            return SeeReference.ReferenceType.METHOD;&#10;        }&#10;&#10;        // Check if it starts with lowercase (likely a function)&#10;        if (!referenceName.isEmpty() &amp;&amp; Character.isLowerCase(referenceName.charAt(0))) {&#10;            return SeeReference.ReferenceType.GLOBAL_FUNCTION;&#10;        }&#10;&#10;        // Default to class for uppercase names&#10;        return SeeReference.ReferenceType.CLASS;&#10;    }&#10;&#10;    /**&#10;     * Parses a type and description from a string, handling union types, generics, and quoted strings.&#10;     * @param input The input string containing type and optional description&#10;     * @return Array with [type, description]&#10;     */&#10;    private static String[] parseTypeAndDescription(String input) {&#10;        if (input == null || input.trim().isEmpty()) {&#10;            return new String[]{&quot;&quot;, &quot;&quot;};&#10;        }&#10;&#10;        input = input.trim();&#10;        StringBuilder typeBuilder = new StringBuilder();&#10;        boolean inQuotes = false;&#10;        int inGeneric = 0; // Track nesting levels for &lt; &gt;&#10;        int inBraces = 0;  // Track nesting levels for { }&#10;        char quoteChar = '\0';&#10;        int i = 0;&#10;&#10;        // Parse the type part character by character&#10;        while (i &lt; input.length()) {&#10;            char c = input.charAt(i);&#10;&#10;            if (!inQuotes &amp;&amp; (c == '\'' || c == '&quot;')) {&#10;                // Start of quoted string&#10;                inQuotes = true;&#10;                quoteChar = c;&#10;                typeBuilder.append(c);&#10;            } else if (inQuotes &amp;&amp; c == quoteChar) {&#10;                // End of quoted string&#10;                inQuotes = false;&#10;                typeBuilder.append(c);&#10;            } else if (!inQuotes &amp;&amp; c == '&lt;') {&#10;                // Start of generic type&#10;                inGeneric++;&#10;                typeBuilder.append(c);&#10;            } else if (!inQuotes &amp;&amp; c == '&gt;') {&#10;                // End of generic type&#10;                inGeneric--;&#10;                typeBuilder.append(c);&#10;            } else if (!inQuotes &amp;&amp; c == '{') {&#10;                // Start of brace block (for table types)&#10;                inBraces++;&#10;                typeBuilder.append(c);&#10;            } else if (!inQuotes &amp;&amp; c == '}') {&#10;                // End of brace block&#10;                inBraces--;&#10;                typeBuilder.append(c);&#10;            } else if (!inQuotes &amp;&amp; inGeneric == 0 &amp;&amp; inBraces == 0 &amp;&amp; Character.isWhitespace(c)) {&#10;                // Found whitespace outside of quotes, generics, and braces - this marks end of type&#10;                break;&#10;            } else {&#10;                typeBuilder.append(c);&#10;            }&#10;            i++;&#10;        }&#10;&#10;        String type = typeBuilder.toString().trim();&#10;&#10;        // Extract description from remaining text&#10;        String description = &quot;&quot;;&#10;        if (i &lt; input.length()) {&#10;            description = input.substring(i).trim();&#10;        }&#10;&#10;        return new String[]{type, description};&#10;    }&#10;&#10;    private static void updateBlockFlags(String line, DocBlock block) {&#10;        if (isClassOrFieldTag(line)) {&#10;            block.hasClassOrFieldTags = true;&#10;        }&#10;&#10;        // Set expectFunction if we have function-related tags (@param, @return, @function) or plain doc lines&#10;        // Make sure we set expectFunction for any function-related documentation&#10;        if (isFunctionTag(line) &amp;&amp; !block.hasClassOrFieldTags &amp;&amp; !line.trim().startsWith(&quot;---@type&quot;)) {&#10;            block.expectFunction = true;&#10;        }&#10;&#10;        // Also set expectFunction for plain doc lines that aren't class/field related&#10;        if (isPlainDocLine(line) &amp;&amp; !block.hasClassOrFieldTags &amp;&amp; !line.trim().startsWith(&quot;---@type&quot;)) {&#10;            block.expectFunction = true;&#10;        }&#10;    }&#10;&#10;    private static boolean isFunctionTag(String line) {&#10;        String trimmed = line.trim();&#10;        return trimmed.startsWith(&quot;---@param&quot;) ||&#10;               trimmed.startsWith(&quot;---@return&quot;) ||&#10;               trimmed.startsWith(&quot;---@function&quot;) ||&#10;               trimmed.startsWith(&quot;---@nodiscard&quot;);&#10;    }&#10;&#10;    private static boolean isClassOrFieldTag(String line) {&#10;        return line.trim().startsWith(&quot;---@class&quot;) || line.trim().startsWith(&quot;---@field&quot;);&#10;    }&#10;&#10;    private static boolean isPlainDocLine(String line) {&#10;        String trimmed = line.trim();&#10;        return trimmed.startsWith(&quot;---&quot;) &amp;&amp; !trimmed.startsWith(&quot;---@&quot;);&#10;    }&#10;&#10;    private static void processCodeLine(String line, DocBlock block, int lineNumber) {&#10;        if (block.expectFunction) {&#10;            // Check if the next line is actually a variable declaration instead of a function&#10;            if (isVariableDeclaration(line)) {&#10;                // This is actually a variable with documentation, treat it as such&#10;                parseVariableDeclaration(line, block);&#10;                block.hasTypeTag = true; // Mark as variable block&#10;                block.expectFunction = false; // No longer expecting a function&#10;                block.lines.add(line);&#10;            } else {&#10;                validateFunctionDeclaration(line, lineNumber);&#10;                parseFunctionName(line, block);&#10;                block.lines.add(line);&#10;            }&#10;        } else if (block.hasTypeTag) {&#10;            // Variable-Deklaration verarbeiten&#10;            parseVariableDeclaration(line, block);&#10;            block.lines.add(line);&#10;        } else if (block.hasClassOrFieldTags) {&#10;            // Class assignment - process normally without requiring function declaration&#10;            parseVariableDeclaration(line, block);&#10;            block.lines.add(line);&#10;        }&#10;    }&#10;&#10;    private static boolean isVariableDeclaration(String line) {&#10;        String trimmedLine = line.trim();&#10;        // Check for variable declarations including nested table assignments&#10;        return trimmedLine.startsWith(&quot;local &quot;) &amp;&amp; trimmedLine.contains(&quot;=&quot;) ||&#10;               (trimmedLine.matches(&quot;[\\w\\.]+\\s*=.*&quot;) &amp;&amp; !trimmedLine.startsWith(&quot;function&quot;) &amp;&amp; !trimmedLine.startsWith(&quot;local function&quot;));&#10;    }&#10;&#10;    private static void parseVariableDeclaration(String line, DocBlock block) {&#10;        String trimmedLine = line.trim();&#10;&#10;        // Pattern für lokale Variablen: local variableName = value&#10;        Pattern localPattern = Pattern.compile(&quot;local\\s+(\\w+)\\s*=&quot;);&#10;        // Pattern für globale Variablen und verschachtelte Tabellen: variableName = value oder Table.property = value&#10;        Pattern globalPattern = Pattern.compile(&quot;([\\w\\.]+)\\s*=&quot;);&#10;&#10;        Matcher localMatcher = localPattern.matcher(trimmedLine);&#10;        Matcher globalMatcher = globalPattern.matcher(trimmedLine);&#10;&#10;        if (localMatcher.find()) {&#10;            // Lokale Variable&#10;            block.variableName = localMatcher.group(1);&#10;            block.isLocalVariable = true;&#10;        } else if (globalMatcher.find()) {&#10;            // Globale Variable oder verschachtelte Tabellenzuweisung&#10;            String fullName = globalMatcher.group(1);&#10;&#10;            // Prüfe, ob es sich um eine verschachtelte Klassenzuweisung handelt&#10;            // z.B. Config.General = {} oder Config.Target.FloatingText = {}&#10;            if (fullName.contains(&quot;.&quot;) &amp;&amp; trimmedLine.contains(&quot;=&quot;) &amp;&amp;&#10;                (trimmedLine.contains(&quot;{}&quot;) || trimmedLine.contains(&quot;= {}&quot;))) {&#10;                // Dies ist wahrscheinlich eine verschachtelte Klasse&#10;                // Verwende den vollen Namen als Klassennamen wenn es bereits einen @class Tag gab&#10;                if (!block.className.isEmpty() &amp;&amp; block.className.equals(fullName)) {&#10;                    // Der Klassenname stimmt mit der Zuweisung überein&#10;                    block.variableName = fullName;&#10;                } else {&#10;                    // Normale Variable mit verschachteltem Namen&#10;                    block.variableName = fullName;&#10;                }&#10;            } else {&#10;                // Normale Variable&#10;                block.variableName = fullName;&#10;            }&#10;            block.isLocalVariable = false;&#10;        }&#10;    }&#10;&#10;    private static void parseFunctionName(String line, DocBlock block) {&#10;        // Pattern für verschiedene Funktionstypen&#10;        Pattern instancePattern = Pattern.compile(&quot;(?:local\\s+)?function\\s+(\\w+):(\\w+)\\s*\\(&quot;);&#10;        Pattern staticPattern = Pattern.compile(&quot;(?:local\\s+)?function\\s+(\\w+)\\.(\\w+)\\s*\\(&quot;);&#10;        Pattern standalonePattern = Pattern.compile(&quot;(?:local\\s+)?function\\s+(\\w+)\\s*\\(&quot;);&#10;&#10;        // Neue Pattern für verschachtelte Funktionszuweisungen&#10;        Pattern nestedFunctionAssignmentPattern = Pattern.compile(&quot;([\\w\\.]+)\\s*=\\s*function\\s*\\(&quot;);&#10;        Pattern localNestedFunctionAssignmentPattern = Pattern.compile(&quot;local\\s+([\\w\\.]+)\\s*=\\s*function\\s*\\(&quot;);&#10;&#10;        Matcher instanceMatcher = instancePattern.matcher(line.trim());&#10;        Matcher staticMatcher = staticPattern.matcher(line.trim());&#10;        Matcher standaloneMatcher = standalonePattern.matcher(line.trim());&#10;        Matcher nestedMatcher = nestedFunctionAssignmentPattern.matcher(line.trim());&#10;        Matcher localNestedMatcher = localNestedFunctionAssignmentPattern.matcher(line.trim());&#10;&#10;        if (instanceMatcher.find()) {&#10;            // Instanz-Methode: ClassName:methodName (kann lokal sein)&#10;            block.functionClassName = instanceMatcher.group(1);&#10;            block.functionName = instanceMatcher.group(2);&#10;            block.isStatic = false;&#10;        } else if (staticMatcher.find()) {&#10;            // Statische Methode: ClassName.staticMethod (kann lokal sein)&#10;            block.functionClassName = staticMatcher.group(1);&#10;            block.functionName = staticMatcher.group(2);&#10;            block.isStatic = true;&#10;        } else if (standaloneMatcher.find()) {&#10;            // Standalone-Funktion (kann lokal sein)&#10;            block.functionName = standaloneMatcher.group(1);&#10;            block.functionClassName = &quot;&quot;;&#10;            block.isStatic = false;&#10;        } else if (localNestedMatcher.find()) {&#10;            // Lokale verschachtelte Funktionszuweisung: local Table.subtable.func = function()&#10;            String fullName = localNestedMatcher.group(1);&#10;            parseNestedFunctionName(fullName, block);&#10;        } else if (nestedMatcher.find()) {&#10;            // Verschachtelte Funktionszuweisung: Table.subtable.func = function()&#10;            String fullName = nestedMatcher.group(1);&#10;            parseNestedFunctionName(fullName, block);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Parst verschachtelte Funktionsnamen wie Server.Core.myFunction&#10;     * @param fullName Der vollständige Name der Funktion (z.B. &quot;Server.Core.myFunction&quot;)&#10;     * @param block Der DocBlock, der aktualisiert werden soll&#10;     */&#10;    private static void parseNestedFunctionName(String fullName, DocBlock block) {&#10;        if (fullName.contains(&quot;.&quot;)) {&#10;            // Finde den letzten Punkt, um den Funktionsnamen zu extrahieren&#10;            int lastDotIndex = fullName.lastIndexOf(&quot;.&quot;);&#10;            String className = fullName.substring(0, lastDotIndex);&#10;            String functionName = fullName.substring(lastDotIndex + 1);&#10;&#10;            block.functionClassName = className;&#10;            block.functionName = functionName;&#10;            block.isStatic = true; // Verschachtelte Zuweisungen sind normalerweise statisch&#10;        } else {&#10;            // Keine Verschachtelung, einfacher Funktionsname&#10;            block.functionName = fullName;&#10;            block.functionClassName = &quot;&quot;;&#10;            block.isStatic = false;&#10;        }&#10;    }&#10;&#10;    private static void validateFunctionDeclaration(String line, int lineNumber) {&#10;        String trimmed = line.trim();&#10;        if (trimmed.startsWith(&quot;function &quot;) || trimmed.startsWith(&quot;local function &quot;) ||&#10;            trimmed.matches(&quot;.*=\\s*function\\s*\\(.*&quot;) || trimmed.matches(&quot;local\\s+.*=\\s*function\\s*\\(.*&quot;)) {&#10;            return;&#10;        }&#10;        throw new RuntimeException(&#10;            String.format(&quot;Expected function declaration after documentation at line %d got '%s'&quot;,&#10;                        lineNumber, line)&#10;        );&#10;    }&#10;&#10;    public static Documentation generate(Path path) {&#10;        try {&#10;            String content = Files.readString(path);&#10;            return generate(content);&#10;        } catch (IOException e) {&#10;            throw new RuntimeException(e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Generates documentation from multiple Lua files.&#10;     * @param filePaths Array of file paths to process&#10;     * @return Combined documentation from all files&#10;     */&#10;    public static Documentation generateFromFiles(String[] filePaths) {&#10;        Documentation combinedDocumentation = new Documentation();&#10;&#10;        for (String filePath : filePaths) {&#10;            try {&#10;                System.out.println(&quot;Processing file: &quot; + filePath);&#10;                Path path = Paths.get(filePath);&#10;                Documentation fileDocumentation = generate(path);&#10;&#10;                // Merge documentation from this file into the combined documentation&#10;                mergeDocumentation(combinedDocumentation, fileDocumentation, filePath);&#10;&#10;            } catch (Exception e) {&#10;                System.err.println(&quot;Error processing file &quot; + filePath + &quot;: &quot; + e.getMessage());&#10;                throw new RuntimeException(&quot;Failed to process file: &quot; + filePath, e);&#10;            }&#10;        }&#10;&#10;        return combinedDocumentation;&#10;    }&#10;&#10;    /**&#10;     * Merges documentation from one file into the combined documentation.&#10;     * @param target The target documentation to merge into&#10;     * @param source The source documentation to merge from&#10;     * @param sourceFileName The name of the source file (for error reporting)&#10;     */&#10;    private static void mergeDocumentation(Documentation target, Documentation source, String sourceFileName) {&#10;        // Check for class name conflicts and merge fields&#10;        for (Class sourceClass : source.classes) {&#10;            Class existingClass = findClassByName(target, sourceClass.name);&#10;            if (existingClass != null) {&#10;                // Class already exists - merge fields and functions instead of skipping&#10;                System.out.println(&quot;Merging class '&quot; + sourceClass.name + &quot;' - adding &quot; +&#10;                    sourceClass.fields.size() + &quot; new fields and &quot; + sourceClass.functions.size() + &quot; new functions&quot;);&#10;&#10;                // Add all new fields from source class to existing class&#10;                for (Field newField : sourceClass.fields) {&#10;                    // Check if field already exists&#10;                    boolean fieldExists = false;&#10;                    for (Field existingField : existingClass.fields) {&#10;                        if (existingField.name.equals(newField.name)) {&#10;                            fieldExists = true;&#10;                            break;&#10;                        }&#10;                    }&#10;                    if (!fieldExists) {&#10;                        existingClass.fields.add(newField);&#10;                    }&#10;                }&#10;&#10;                // Add all new functions from source class to existing class&#10;                for (Function newFunction : sourceClass.functions) {&#10;                    // Check if function already exists&#10;                    boolean functionExists = false;&#10;                    for (Function existingFunction : existingClass.functions) {&#10;                        if (existingFunction.name.equals(newFunction.name)) {&#10;                            functionExists = true;&#10;                            break;&#10;                        }&#10;                    }&#10;                    if (!functionExists) {&#10;                        existingClass.functions.add(newFunction);&#10;                    }&#10;                }&#10;&#10;                // Merge parent classes if they don't already exist&#10;                for (String newParent : sourceClass.parent) {&#10;                    if (!existingClass.parent.contains(newParent)) {&#10;                        existingClass.parent.add(newParent);&#10;                    }&#10;                }&#10;            } else {&#10;                // New class - add it normally&#10;                target.addClass(sourceClass);&#10;            }&#10;        }&#10;&#10;        // Add all functions (global functions can have the same name in different contexts)&#10;        for (Function function : source.functions) {&#10;            target.addFunction(function);&#10;        }&#10;&#10;        // Add all variables&#10;        for (Variable variable : source.variables) {&#10;            target.addVariable(variable);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Checks if a function block represents a local function.&#10;     * @param block The doc block to check&#10;     * @return true if this is a local function&#10;     */&#10;    private static boolean isLocalFunction(DocBlock block) {&#10;        // Check if any line in the block contains &quot;local function&quot;&#10;        for (String line : block.lines) {&#10;            if (line.trim().startsWith(&quot;local function&quot;)) {&#10;                return true;&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;&#10;    private static void processStandaloneFields(List&lt;DocBlock&gt; blocks, Documentation documentation) {&#10;        // Verarbeite @field Blöcke die nach Klassendefinitionen stehen&#10;        for (DocBlock block : blocks) {&#10;            // Suche nach @field Blöcken ohne eigene Klassendefinition&#10;            if (!block.fields.isEmpty() &amp;&amp; block.className.isEmpty()) {&#10;                // Analysiere die Code-Zeilen, um die Zielklasse zu bestimmen&#10;                String targetClassName = findTargetClassForFields(block, documentation);&#10;&#10;                if (targetClassName != null) {&#10;                    Class targetClass = findClassByName(documentation, targetClassName);&#10;                    if (targetClass != null) {&#10;                        // Füge alle Felder zur gefundenen Klasse hinzu&#10;                        targetClass.fields.addAll(block.fields);&#10;                    }&#10;                } else {&#10;                    // Wenn keine Zielklasse gefunden wurde, versuche aus den @field Namen zu inferieren&#10;                    for (Field field : block.fields) {&#10;                        // Suche nach einer Klasse basierend auf Code-Zeilen&#10;                        String inferredClassName = inferClassNameFromCodeLines(block, field.name, documentation);&#10;                        if (inferredClassName != null) {&#10;                            Class targetClass = findClassByName(documentation, inferredClassName);&#10;                            if (targetClass != null) {&#10;                                targetClass.fields.add(field);&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private static String findTargetClassForFields(DocBlock fieldBlock, Documentation documentation) {&#10;        // Analysiere die Code-Zeilen im Field-Block, um die Zielklasse zu finden&#10;        for (String line : fieldBlock.lines) {&#10;            String trimmed = line.trim();&#10;            // Suche nach Zuweisungen wie &quot;Config.General.name = ...&quot;&#10;            if (trimmed.matches(&quot;[\\w.]+\\s*=.*&quot;)) {&#10;                Pattern pattern = Pattern.compile(&quot;([\\w.]+)\\.[\\w]+\\s*=&quot;);&#10;                Matcher matcher = pattern.matcher(trimmed);&#10;                if (matcher.find()) {&#10;                    String possibleClassName = matcher.group(1);&#10;                    // Prüfe, ob diese Klasse existiert&#10;                    if (findClassByName(documentation, possibleClassName) != null) {&#10;                        return possibleClassName;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;&#10;    private static String inferClassNameFromCodeLines(DocBlock block, String fieldName, Documentation documentation) {&#10;        // Suche nach Code-Zeilen, die den Feldnamen verwenden&#10;        for (String line : block.lines) {&#10;            String trimmed = line.trim();&#10;            // Pattern für Zuweisungen wie &quot;Config.General.fieldName = ...&quot;&#10;            if (trimmed.contains(fieldName) &amp;&amp; trimmed.contains(&quot;=&quot;)) {&#10;                Pattern pattern = Pattern.compile(&quot;([\\w.]+)\\.&quot; + Pattern.quote(fieldName) + &quot;\\s*=&quot;);&#10;                Matcher matcher = pattern.matcher(trimmed);&#10;                if (matcher.find()) {&#10;                    String possibleClassName = matcher.group(1);&#10;                    // Prüfe, ob diese Klasse existiert&#10;                    if (findClassByName(documentation, possibleClassName) != null) {&#10;                        return possibleClassName;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package de.fb.ldg;&#10;&#10;import java.io.IOException;&#10;import java.nio.file.Files;&#10;import java.nio.file.Path;&#10;import java.nio.file.Paths;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.regex.Matcher;&#10;import java.util.regex.Pattern;&#10;&#10;public class DocGenerator {&#10;&#10;    private static class DocBlock {&#10;        boolean hadContent = false;&#10;        boolean expectFunction = false;&#10;        boolean hasClassOrFieldTags = false;&#10;        boolean hasTypeTag = false; // Für @type Annotations&#10;&#10;        List&lt;String&gt; lines = new ArrayList&lt;&gt;();&#10;        String description = &quot;&quot;;&#10;        List&lt;String&gt; examples = new ArrayList&lt;&gt;(); // Code-Beispiele&#10;        List&lt;SeeReference&gt; seeReferences = new ArrayList&lt;&gt;(); // @see Referenzen&#10;        String className = &quot;&quot;;&#10;        List&lt;String&gt; classParents = new ArrayList&lt;&gt;();&#10;        List&lt;Field&gt; fields = new ArrayList&lt;&gt;();&#10;        String functionName = &quot;&quot;;&#10;        String functionClassName = &quot;&quot;; // Klasse zu der die Funktion gehört&#10;        boolean isStatic = false; // Ob die Funktion statisch ist&#10;        List&lt;Function.Parameter&gt; parameters = new ArrayList&lt;&gt;();&#10;        String returnType = &quot;&quot;;&#10;        String returnDescription = &quot;&quot;;&#10;        boolean nodiscard = false;&#10;&#10;        // Variable-spezifische Felder&#10;        String variableName = &quot;&quot;;&#10;        String variableType = &quot;&quot;;&#10;        String variableDescription = &quot;&quot;;&#10;        boolean isLocalVariable = false;&#10;&#10;        boolean inCodeBlock = false; // Ob wir uns in einem Codeblock befinden (zwischen ```)&#10;&#10;        @Override&#10;        public String toString() {&#10;            StringBuilder sb = new StringBuilder();&#10;            sb.append(&quot;[BLOCK_TYPE=&quot;).append(hasClassOrFieldTags ? &quot;CLASS&quot; : &quot;FUNCTION&quot;).append(&quot;]\n&quot;);&#10;            for (String line : lines) {&#10;                sb.append(line).append(&quot;\n&quot;);&#10;            }&#10;            return sb.toString();&#10;        }&#10;    }&#10;&#10;    public static Documentation generate(String content) {&#10;        Documentation documentation = new Documentation();&#10;        List&lt;DocBlock&gt; blocks = new ArrayList&lt;&gt;();&#10;        DocBlock block = new DocBlock();&#10;&#10;        int lineNumber = 1;&#10;        String[] lines = content.split(&quot;\n&quot;);&#10;        for (int i = 0; i &lt; lines.length; i++) {&#10;            String line = lines[i];&#10;&#10;            if (isDocLine(line)) {&#10;                processDocLine(line, block);&#10;                block.lines.add(line);&#10;            } else if (block.hadContent) {&#10;                processCodeLine(line, block, lineNumber);&#10;                blocks.add(block);&#10;                block = new DocBlock();&#10;            }&#10;&#10;            lineNumber++;&#10;        }&#10;&#10;        // Zuerst alle Klassen sammeln&#10;        for (DocBlock b : blocks) {&#10;            if (b.hasClassOrFieldTags) {&#10;                processClassBlock(b, documentation);&#10;            }&#10;        }&#10;&#10;        // Dann Funktionen verarbeiten und den Klassen zuordnen&#10;        for (DocBlock b : blocks) {&#10;            if (b.expectFunction) {&#10;                processFunctionBlock(b, documentation);&#10;            }&#10;        }&#10;&#10;        // Dann Variablen verarbeiten - dabei auch Felder zu Klassen zuordnen&#10;        for (DocBlock b : blocks) {&#10;            if (b.hasTypeTag) {&#10;                processVariableBlock(b, documentation);&#10;            }&#10;        }&#10;&#10;        // Zusätzlich: Standalone @field Blöcke verarbeiten&#10;        processStandaloneFields(blocks, documentation);&#10;&#10;        return documentation;&#10;    }&#10;&#10;    private static void processClassBlock(DocBlock block, Documentation documentation) {&#10;        if (!block.className.isEmpty()) {&#10;            // Debug output to see what's happening&#10;            System.out.println(&quot;Processing class: &quot; + block.className + &quot; with &quot; + block.fields.size() + &quot; fields&quot;);&#10;            for (Field field : block.fields) {&#10;                System.out.println(&quot;  Field: &quot; + field.name + &quot; (&quot; + field.type + &quot;)&quot;);&#10;            }&#10;&#10;            // Create class with fields from the same block and see references&#10;            Class clazz = new Class(block.className, block.classParents, new ArrayList&lt;&gt;(block.fields), new ArrayList&lt;&gt;(), block.seeReferences);&#10;            documentation.addClass(clazz);&#10;        }&#10;    }&#10;&#10;    private static void processFunctionBlock(DocBlock block, Documentation documentation) {&#10;        if (!block.functionName.isEmpty()) {&#10;            // Skip local functions - they are not part of the public API&#10;            if (isLocalFunction(block)) {&#10;                return;&#10;            }&#10;&#10;            Function function = new Function(&#10;                block.functionName,&#10;                block.description,&#10;                block.parameters,&#10;                block.returnType,&#10;                block.returnDescription,&#10;                block.nodiscard,&#10;                block.isStatic,&#10;                block.examples,&#10;                block.seeReferences&#10;            );&#10;&#10;            // Prüfen, ob die Funktion zu einer Klasse gehört&#10;            if (!block.functionClassName.isEmpty()) {&#10;                // Funktion zur entsprechenden Klasse hinzufügen&#10;                Class targetClass = findClassByName(documentation, block.functionClassName);&#10;                if (targetClass != null) {&#10;                    targetClass.functions.add(function);&#10;                } else {&#10;                    // Wenn Klasse nicht gefunden, als standalone Funktion hinzufügen&#10;                    documentation.addFunction(function);&#10;                }&#10;            } else {&#10;                // Standalone Funktion&#10;                documentation.addFunction(function);&#10;            }&#10;        }&#10;    }&#10;&#10;    private static void processVariableBlock(DocBlock block, Documentation documentation) {&#10;        if (!block.variableName.isEmpty()) {&#10;            // Skip local variables - they are not part of the public API&#10;            if (block.isLocalVariable) {&#10;                return;&#10;            }&#10;&#10;            // Check if this variable name matches a class name (for nested classes)&#10;            // If we have a @class tag and the variable name matches, don't process as variable&#10;            if (!block.className.isEmpty() &amp;&amp; block.variableName.equals(block.className)) {&#10;                // This is a class assignment, not a variable - skip it&#10;                return;&#10;            }&#10;&#10;            // Check if this is a class field assignment (e.g., Config.my_value)&#10;            if (block.variableName.contains(&quot;.&quot;)) {&#10;                String[] parts = block.variableName.split(&quot;\\.&quot;, 2);&#10;                String className = parts[0];&#10;                String fieldName = parts[1];&#10;&#10;                // Skip assignments to nested objects (e.g., Config.General.framework)&#10;                // These are value assignments to already defined nested classes, not field definitions&#10;                if (fieldName.contains(&quot;.&quot;)) {&#10;                    // This is a nested assignment like Config.General.framework = &quot;value&quot;&#10;                    // Skip it as it's not a field definition but a value assignment&#10;                    return;&#10;                }&#10;&#10;                // Find the class and add this as a field&#10;                Class targetClass = findClassByName(documentation, className);&#10;                if (targetClass != null) {&#10;                    // Create a field for this class property&#10;                    Field field = new Field(fieldName, block.variableType, &quot;public&quot;, block.variableDescription);&#10;                    targetClass.fields.add(field);&#10;                    return; // Don't add as global variable&#10;                }&#10;            }&#10;&#10;            Variable variable = new Variable(block.variableName, block.variableType, block.variableDescription, block.isLocalVariable);&#10;            documentation.addVariable(variable);&#10;        }&#10;    }&#10;&#10;    private static Class findClassByName(Documentation documentation, String className) {&#10;        for (Class clazz : documentation.classes) {&#10;            if (clazz.name.equals(className)) {&#10;                return clazz;&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;&#10;    private static boolean isDocLine(String line) {&#10;        return line.trim().startsWith(&quot;---&quot;);&#10;    }&#10;&#10;    private static void processDocLine(String line, DocBlock block) {&#10;        updateBlockFlags(line, block);&#10;        parseDocContent(line, block);&#10;        block.hadContent = true;&#10;    }&#10;&#10;    private static void parseDocContent(String line, DocBlock block) {&#10;        line = line.trim();&#10;&#10;        if (line.startsWith(&quot;---@class&quot;)) {&#10;            parseClassLine(line, block);&#10;        } else if (line.startsWith(&quot;---@field&quot;)) {&#10;            parseFieldLine(line, block);&#10;        } else if (line.startsWith(&quot;---@param&quot;)) {&#10;            parseParamLine(line, block);&#10;        } else if (line.startsWith(&quot;---@return&quot;)) {&#10;            parseReturnLine(line, block);&#10;        } else if (line.startsWith(&quot;---@nodiscard&quot;)) {&#10;            block.nodiscard = true;&#10;        } else if (line.startsWith(&quot;---&quot;) &amp;&amp; !line.startsWith(&quot;---@&quot;)) {&#10;            // Plain description line - check for code blocks&#10;            String desc = line.substring(3).trim();&#10;            parseDescriptionWithCodeBlocks(desc, block);&#10;        } else if (line.startsWith(&quot;---@type&quot;)) {&#10;            parseTypeLine(line, block);&#10;        } else if (line.startsWith(&quot;---@see&quot;)) {&#10;            parseSeeLine(line, block);&#10;        }&#10;    }&#10;&#10;    private static void parseDescriptionWithCodeBlocks(String desc, DocBlock block) {&#10;        // Check if this line starts or ends a code block&#10;        if (desc.startsWith(&quot;```&quot;)) {&#10;            if (block.inCodeBlock) {&#10;                // End of code block&#10;                block.inCodeBlock = false;&#10;                // Don't add the closing ``` to examples&#10;            } else {&#10;                // Start of code block&#10;                block.inCodeBlock = true;&#10;                // Don't add the opening ``` to examples&#10;            }&#10;        } else if (block.inCodeBlock) {&#10;            // We're inside a code block, add this line to examples&#10;            if (!desc.isEmpty()) {&#10;                block.examples.add(desc);&#10;            }&#10;        } else {&#10;            // Normal description line&#10;            if (!desc.isEmpty()) {&#10;                if (!block.description.isEmpty()) {&#10;                    block.description += &quot; &quot;;&#10;                }&#10;                block.description += desc;&#10;            }&#10;        }&#10;    }&#10;&#10;    private static void parseClassLine(String line, DocBlock block) {&#10;        // Pattern: ---@class ClassName : ParentClass description&#10;        // Updated to support complex parent types like Parent&lt;{field: type}&gt;&#10;        String content = line.trim().replaceFirst(&quot;^---@class\\s+&quot;, &quot;&quot;);&#10;&#10;        // Split by first whitespace to get class name&#10;        String[] firstSplit = content.split(&quot;\\s+&quot;, 2);&#10;        if (firstSplit.length == 0) return;&#10;&#10;        String classNamePart = firstSplit[0];&#10;        String remaining = firstSplit.length &gt; 1 ? firstSplit[1] : &quot;&quot;;&#10;&#10;        // Check if class name contains inheritance separator ':'&#10;        if (classNamePart.contains(&quot;:&quot;)) {&#10;            String[] classParts = classNamePart.split(&quot;:&quot;, 2);&#10;            block.className = classParts[0].trim();&#10;&#10;            // Parse the parent type (could be complex) + remaining description&#10;            String parentAndDesc = classParts[1].trim();&#10;            if (!remaining.isEmpty()) {&#10;                parentAndDesc += &quot; &quot; + remaining;&#10;            }&#10;&#10;            // Use the same parsing logic as for types to handle complex parent types&#10;            String[] parentTypeAndDesc = parseTypeAndDescription(parentAndDesc);&#10;            String parentType = parentTypeAndDesc[0];&#10;            String description = parentTypeAndDesc[1];&#10;&#10;            if (!parentType.isEmpty()) {&#10;                block.classParents.add(parentType);&#10;            }&#10;            if (!description.isEmpty()) {&#10;                block.description = description;&#10;            }&#10;        } else {&#10;            // No inheritance, check if remaining part starts with ':'&#10;            block.className = classNamePart;&#10;&#10;            if (!remaining.isEmpty() &amp;&amp; remaining.startsWith(&quot;:&quot;)) {&#10;                // Remove the ':' and parse parent type + description&#10;                String parentAndDesc = remaining.substring(1).trim();&#10;                String[] parentTypeAndDesc = parseTypeAndDescription(parentAndDesc);&#10;                String parentType = parentTypeAndDesc[0];&#10;                String description = parentTypeAndDesc[1];&#10;&#10;                if (!parentType.isEmpty()) {&#10;                    block.classParents.add(parentType);&#10;                }&#10;                if (!description.isEmpty()) {&#10;                    block.description = description;&#10;                }&#10;            } else if (!remaining.isEmpty()) {&#10;                // Just description, no inheritance&#10;                block.description = remaining;&#10;            }&#10;        }&#10;    }&#10;&#10;    private static void parseFieldLine(String line, DocBlock block) {&#10;        // Remove the @field prefix&#10;        String content = line.trim().replaceFirst(&quot;^---@field\\s+&quot;, &quot;&quot;);&#10;&#10;        // Split by first whitespace to get field name&#10;        String[] firstSplit = content.split(&quot;\\s+&quot;, 2);&#10;        if (firstSplit.length &lt; 2) return;&#10;&#10;        String fieldName = firstSplit[0];&#10;        String remaining = firstSplit[1];&#10;&#10;        // Check if field name includes visibility modifier&#10;        String visibility = &quot;public&quot;; // Default&#10;        String actualFieldName = fieldName;&#10;&#10;        if (fieldName.equals(&quot;public&quot;) || fieldName.equals(&quot;private&quot;) || fieldName.equals(&quot;protected&quot;)) {&#10;            // Visibility modifier present&#10;            String[] secondSplit = remaining.split(&quot;\\s+&quot;, 2);&#10;            if (secondSplit.length &lt; 2) return;&#10;&#10;            visibility = fieldName;&#10;            actualFieldName = secondSplit[0];&#10;            remaining = secondSplit[1];&#10;        }&#10;&#10;        // Parse type and description&#10;        String[] typeAndDesc = parseTypeAndDescription(remaining);&#10;        String fieldType = typeAndDesc[0];&#10;        String description = typeAndDesc[1];&#10;&#10;        Field field = new Field(actualFieldName, fieldType, visibility, description);&#10;        block.fields.add(field);&#10;&#10;        // Debug output&#10;        System.out.println(&quot;Parsed field: &quot; + actualFieldName + &quot; (&quot; + fieldType + &quot;) - &quot; + description);&#10;    }&#10;&#10;    private static void parseParamLine(String line, DocBlock block) {&#10;        // Pattern: ---@param paramName type description&#10;        // Updated to handle union types like 'esx'|'qb' and complex types&#10;        String content = line.trim().replaceFirst(&quot;^---@param\\s+&quot;, &quot;&quot;);&#10;&#10;        // Split by first whitespace to get parameter name&#10;        String[] firstSplit = content.split(&quot;\\s+&quot;, 2);&#10;        if (firstSplit.length &lt; 2) return;&#10;&#10;        String paramName = firstSplit[0];&#10;        String remaining = firstSplit[1];&#10;&#10;        // Parse type (can contain unions, generics, etc.)&#10;        String[] typeAndDesc = parseTypeAndDescription(remaining);&#10;        String paramType = typeAndDesc[0];&#10;        String description = typeAndDesc[1];&#10;&#10;        Function.Parameter param = new Function.Parameter(paramName, paramType, description);&#10;        block.parameters.add(param);&#10;    }&#10;&#10;    private static void parseReturnLine(String line, DocBlock block) {&#10;        // Pattern: ---@return type description&#10;        // Updated to handle union types and complex types&#10;        String content = line.trim().replaceFirst(&quot;^---@return\\s+&quot;, &quot;&quot;);&#10;&#10;        String[] typeAndDesc = parseTypeAndDescription(content);&#10;        block.returnType = typeAndDesc[0];&#10;        block.returnDescription = typeAndDesc[1];&#10;    }&#10;&#10;    private static void parseTypeLine(String line, DocBlock block) {&#10;        // Pattern: ---@type type description&#10;        // Updated to handle union types and complex types&#10;        String content = line.trim().replaceFirst(&quot;^---@type\\s+&quot;, &quot;&quot;);&#10;&#10;        String[] typeAndDesc = parseTypeAndDescription(content);&#10;        block.variableType = typeAndDesc[0];&#10;        block.variableDescription = typeAndDesc[1];&#10;        block.hasTypeTag = true;&#10;    }&#10;&#10;    private static void parseSeeLine(String line, DocBlock block) {&#10;        // Pattern: ---@see ClassName [description]&#10;        String content = line.trim().replaceFirst(&quot;^---@see\\s+&quot;, &quot;&quot;);&#10;&#10;        if (!content.isEmpty()) {&#10;            // Split by first whitespace to separate reference name from description&#10;            String[] parts = content.split(&quot;\\s+&quot;, 2);&#10;            String referenceName = parts[0];&#10;            String description = parts.length &gt; 1 ? parts[1] : &quot;&quot;;&#10;&#10;            // Determine the type of reference based on the name pattern&#10;            SeeReference.ReferenceType type = determineReferenceType(referenceName);&#10;            SeeReference ref = new SeeReference(referenceName, type, description);&#10;            block.seeReferences.add(ref);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Determines the type of a @see reference based on its name pattern.&#10;     * @param referenceName The name of the reference&#10;     * @return The determined reference type&#10;     */&#10;    private static SeeReference.ReferenceType determineReferenceType(String referenceName) {&#10;        // If it contains a dot, it's likely a method (ClassName.methodName)&#10;        if (referenceName.contains(&quot;.&quot;)) {&#10;            return SeeReference.ReferenceType.METHOD;&#10;        }&#10;&#10;        // Check if it starts with lowercase (likely a function)&#10;        if (!referenceName.isEmpty() &amp;&amp; Character.isLowerCase(referenceName.charAt(0))) {&#10;            return SeeReference.ReferenceType.GLOBAL_FUNCTION;&#10;        }&#10;&#10;        // Default to class for uppercase names&#10;        return SeeReference.ReferenceType.CLASS;&#10;    }&#10;&#10;    /**&#10;     * Parses a type and description from a string, handling union types, generics, and quoted strings.&#10;     * @param input The input string containing type and optional description&#10;     * @return Array with [type, description]&#10;     */&#10;    private static String[] parseTypeAndDescription(String input) {&#10;        if (input == null || input.trim().isEmpty()) {&#10;            return new String[]{&quot;&quot;, &quot;&quot;};&#10;        }&#10;&#10;        input = input.trim();&#10;        StringBuilder typeBuilder = new StringBuilder();&#10;        boolean inQuotes = false;&#10;        int inGeneric = 0; // Track nesting levels for &lt; &gt;&#10;        int inBraces = 0;  // Track nesting levels for { }&#10;        char quoteChar = '\0';&#10;        int i = 0;&#10;&#10;        // Parse the type part character by character&#10;        while (i &lt; input.length()) {&#10;            char c = input.charAt(i);&#10;&#10;            if (!inQuotes &amp;&amp; (c == '\'' || c == '&quot;')) {&#10;                // Start of quoted string&#10;                inQuotes = true;&#10;                quoteChar = c;&#10;                typeBuilder.append(c);&#10;            } else if (inQuotes &amp;&amp; c == quoteChar) {&#10;                // End of quoted string&#10;                inQuotes = false;&#10;                typeBuilder.append(c);&#10;            } else if (!inQuotes &amp;&amp; c == '&lt;') {&#10;                // Start of generic type&#10;                inGeneric++;&#10;                typeBuilder.append(c);&#10;            } else if (!inQuotes &amp;&amp; c == '&gt;') {&#10;                // End of generic type&#10;                inGeneric--;&#10;                typeBuilder.append(c);&#10;            } else if (!inQuotes &amp;&amp; c == '{') {&#10;                // Start of brace block (for table types)&#10;                inBraces++;&#10;                typeBuilder.append(c);&#10;            } else if (!inQuotes &amp;&amp; c == '}') {&#10;                // End of brace block&#10;                inBraces--;&#10;                typeBuilder.append(c);&#10;            } else if (!inQuotes &amp;&amp; inGeneric == 0 &amp;&amp; inBraces == 0 &amp;&amp; Character.isWhitespace(c)) {&#10;                // Found whitespace outside of quotes, generics, and braces - this marks end of type&#10;                break;&#10;            } else {&#10;                typeBuilder.append(c);&#10;            }&#10;            i++;&#10;        }&#10;&#10;        String type = typeBuilder.toString().trim();&#10;&#10;        // Extract description from remaining text&#10;        String description = &quot;&quot;;&#10;        if (i &lt; input.length()) {&#10;            description = input.substring(i).trim();&#10;        }&#10;&#10;        return new String[]{type, description};&#10;    }&#10;&#10;    private static void updateBlockFlags(String line, DocBlock block) {&#10;        if (isClassOrFieldTag(line)) {&#10;            block.hasClassOrFieldTags = true;&#10;        }&#10;&#10;        // Set expectFunction if we have function-related tags (@param, @return, @function) or plain doc lines&#10;        // Make sure we set expectFunction for any function-related documentation&#10;        if (isFunctionTag(line) &amp;&amp; !block.hasClassOrFieldTags &amp;&amp; !line.trim().startsWith(&quot;---@type&quot;)) {&#10;            block.expectFunction = true;&#10;        }&#10;&#10;        // Also set expectFunction for plain doc lines that aren't class/field related&#10;        if (isPlainDocLine(line) &amp;&amp; !block.hasClassOrFieldTags &amp;&amp; !line.trim().startsWith(&quot;---@type&quot;)) {&#10;            block.expectFunction = true;&#10;        }&#10;    }&#10;&#10;    private static boolean isFunctionTag(String line) {&#10;        String trimmed = line.trim();&#10;        return trimmed.startsWith(&quot;---@param&quot;) ||&#10;               trimmed.startsWith(&quot;---@return&quot;) ||&#10;               trimmed.startsWith(&quot;---@function&quot;) ||&#10;               trimmed.startsWith(&quot;---@nodiscard&quot;);&#10;    }&#10;&#10;    private static boolean isClassOrFieldTag(String line) {&#10;        return line.trim().startsWith(&quot;---@class&quot;) || line.trim().startsWith(&quot;---@field&quot;);&#10;    }&#10;&#10;    private static boolean isPlainDocLine(String line) {&#10;        String trimmed = line.trim();&#10;        return trimmed.startsWith(&quot;---&quot;) &amp;&amp; !trimmed.startsWith(&quot;---@&quot;);&#10;    }&#10;&#10;    private static void processCodeLine(String line, DocBlock block, int lineNumber) {&#10;        if (block.expectFunction) {&#10;            // Check if the next line is actually a variable declaration instead of a function&#10;            if (isVariableDeclaration(line)) {&#10;                // This is actually a variable with documentation, treat it as such&#10;                parseVariableDeclaration(line, block);&#10;                block.hasTypeTag = true; // Mark as variable block&#10;                block.expectFunction = false; // No longer expecting a function&#10;                block.lines.add(line);&#10;            } else {&#10;                validateFunctionDeclaration(line, lineNumber);&#10;                parseFunctionName(line, block);&#10;                block.lines.add(line);&#10;            }&#10;        } else if (block.hasTypeTag) {&#10;            // Variable-Deklaration verarbeiten&#10;            parseVariableDeclaration(line, block);&#10;            block.lines.add(line);&#10;        } else if (block.hasClassOrFieldTags) {&#10;            // Class assignment - process normally without requiring function declaration&#10;            parseVariableDeclaration(line, block);&#10;            block.lines.add(line);&#10;        }&#10;    }&#10;&#10;    private static boolean isVariableDeclaration(String line) {&#10;        String trimmedLine = line.trim();&#10;        // Prüfe zuerst, ob es sich um eine Funktionszuweisung handelt&#10;        if (trimmedLine.matches(&quot;.*=\\s*function\\s*\\(.*&quot;)) {&#10;            return false; // Das ist eine Funktionszuweisung, keine Variable&#10;        }&#10;        &#10;        // Check for variable declarations including nested table assignments&#10;        return trimmedLine.startsWith(&quot;local &quot;) &amp;&amp; trimmedLine.contains(&quot;=&quot;) ||&#10;               (trimmedLine.matches(&quot;[\\w\\.]+\\s*=.*&quot;) &amp;&amp; !trimmedLine.startsWith(&quot;function&quot;) &amp;&amp; !trimmedLine.startsWith(&quot;local function&quot;));&#10;    }&#10;&#10;    private static void parseVariableDeclaration(String line, DocBlock block) {&#10;        String trimmedLine = line.trim();&#10;&#10;        // Pattern für lokale Variablen: local variableName = value&#10;        Pattern localPattern = Pattern.compile(&quot;local\\s+(\\w+)\\s*=&quot;);&#10;        // Pattern für globale Variablen und verschachtelte Tabellen: variableName = value oder Table.property = value&#10;        Pattern globalPattern = Pattern.compile(&quot;([\\w\\.]+)\\s*=&quot;);&#10;&#10;        Matcher localMatcher = localPattern.matcher(trimmedLine);&#10;        Matcher globalMatcher = globalPattern.matcher(trimmedLine);&#10;&#10;        if (localMatcher.find()) {&#10;            // Lokale Variable&#10;            block.variableName = localMatcher.group(1);&#10;            block.isLocalVariable = true;&#10;        } else if (globalMatcher.find()) {&#10;            // Globale Variable oder verschachtelte Tabellenzuweisung&#10;            String fullName = globalMatcher.group(1);&#10;&#10;            // Prüfe, ob es sich um eine verschachtelte Klassenzuweisung handelt&#10;            // z.B. Config.General = {} oder Config.Target.FloatingText = {}&#10;            if (fullName.contains(&quot;.&quot;) &amp;&amp; trimmedLine.contains(&quot;=&quot;) &amp;&amp;&#10;                (trimmedLine.contains(&quot;{}&quot;) || trimmedLine.contains(&quot;= {}&quot;))) {&#10;                // Dies ist wahrscheinlich eine verschachtelte Klasse&#10;                // Verwende den vollen Namen als Klassennamen wenn es bereits einen @class Tag gab&#10;                if (!block.className.isEmpty() &amp;&amp; block.className.equals(fullName)) {&#10;                    // Der Klassenname stimmt mit der Zuweisung überein&#10;                    block.variableName = fullName;&#10;                } else {&#10;                    // Normale Variable mit verschachteltem Namen&#10;                    block.variableName = fullName;&#10;                }&#10;            } else {&#10;                // Normale Variable&#10;                block.variableName = fullName;&#10;            }&#10;            block.isLocalVariable = false;&#10;        }&#10;    }&#10;&#10;    private static void parseFunctionName(String line, DocBlock block) {&#10;        // Pattern für verschiedene Funktionstypen&#10;        Pattern instancePattern = Pattern.compile(&quot;(?:local\\s+)?function\\s+(\\w+):(\\w+)\\s*\\(&quot;);&#10;        Pattern staticPattern = Pattern.compile(&quot;(?:local\\s+)?function\\s+(\\w+)\\.(\\w+)\\s*\\(&quot;);&#10;        Pattern standalonePattern = Pattern.compile(&quot;(?:local\\s+)?function\\s+(\\w+)\\s*\\(&quot;);&#10;&#10;        // Neue Pattern für verschachtelte Funktionszuweisungen&#10;        Pattern nestedFunctionAssignmentPattern = Pattern.compile(&quot;([\\w\\.]+)\\s*=\\s*function\\s*\\(&quot;);&#10;        Pattern localNestedFunctionAssignmentPattern = Pattern.compile(&quot;local\\s+([\\w\\.]+)\\s*=\\s*function\\s*\\(&quot;);&#10;&#10;        Matcher instanceMatcher = instancePattern.matcher(line.trim());&#10;        Matcher staticMatcher = staticPattern.matcher(line.trim());&#10;        Matcher standaloneMatcher = standalonePattern.matcher(line.trim());&#10;        Matcher nestedMatcher = nestedFunctionAssignmentPattern.matcher(line.trim());&#10;        Matcher localNestedMatcher = localNestedFunctionAssignmentPattern.matcher(line.trim());&#10;&#10;        if (instanceMatcher.find()) {&#10;            // Instanz-Methode: ClassName:methodName (kann lokal sein)&#10;            block.functionClassName = instanceMatcher.group(1);&#10;            block.functionName = instanceMatcher.group(2);&#10;            block.isStatic = false;&#10;        } else if (staticMatcher.find()) {&#10;            // Statische Methode: ClassName.staticMethod (kann lokal sein)&#10;            block.functionClassName = staticMatcher.group(1);&#10;            block.functionName = staticMatcher.group(2);&#10;            block.isStatic = true;&#10;        } else if (standaloneMatcher.find()) {&#10;            // Standalone-Funktion (kann lokal sein)&#10;            block.functionName = standaloneMatcher.group(1);&#10;            block.functionClassName = &quot;&quot;;&#10;            block.isStatic = false;&#10;        } else if (localNestedMatcher.find()) {&#10;            // Lokale verschachtelte Funktionszuweisung: local Table.subtable.func = function()&#10;            String fullName = localNestedMatcher.group(1);&#10;            parseNestedFunctionName(fullName, block);&#10;        } else if (nestedMatcher.find()) {&#10;            // Verschachtelte Funktionszuweisung: Table.subtable.func = function()&#10;            String fullName = nestedMatcher.group(1);&#10;            parseNestedFunctionName(fullName, block);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Parst verschachtelte Funktionsnamen wie Server.Core.myFunction&#10;     * @param fullName Der vollständige Name der Funktion (z.B. &quot;Server.Core.myFunction&quot;)&#10;     * @param block Der DocBlock, der aktualisiert werden soll&#10;     */&#10;    private static void parseNestedFunctionName(String fullName, DocBlock block) {&#10;        if (fullName.contains(&quot;.&quot;)) {&#10;            // Finde den letzten Punkt, um den Funktionsnamen zu extrahieren&#10;            int lastDotIndex = fullName.lastIndexOf(&quot;.&quot;);&#10;            String className = fullName.substring(0, lastDotIndex);&#10;            String functionName = fullName.substring(lastDotIndex + 1);&#10;&#10;            block.functionClassName = className;&#10;            block.functionName = functionName;&#10;            block.isStatic = true; // Verschachtelte Zuweisungen sind normalerweise statisch&#10;        } else {&#10;            // Keine Verschachtelung, einfacher Funktionsname&#10;            block.functionName = fullName;&#10;            block.functionClassName = &quot;&quot;;&#10;            block.isStatic = false;&#10;        }&#10;    }&#10;&#10;    private static void validateFunctionDeclaration(String line, int lineNumber) {&#10;        String trimmed = line.trim();&#10;        if (trimmed.startsWith(&quot;function &quot;) || trimmed.startsWith(&quot;local function &quot;) ||&#10;            trimmed.matches(&quot;.*=\\s*function\\s*\\(.*&quot;) || trimmed.matches(&quot;local\\s+.*=\\s*function\\s*\\(.*&quot;)) {&#10;            return;&#10;        }&#10;        throw new RuntimeException(&#10;            String.format(&quot;Expected function declaration after documentation at line %d got '%s'&quot;,&#10;                        lineNumber, line)&#10;        );&#10;    }&#10;&#10;    public static Documentation generate(Path path) {&#10;        try {&#10;            String content = Files.readString(path);&#10;            return generate(content);&#10;        } catch (IOException e) {&#10;            throw new RuntimeException(e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Generates documentation from multiple Lua files.&#10;     * @param filePaths Array of file paths to process&#10;     * @return Combined documentation from all files&#10;     */&#10;    public static Documentation generateFromFiles(String[] filePaths) {&#10;        Documentation combinedDocumentation = new Documentation();&#10;&#10;        for (String filePath : filePaths) {&#10;            try {&#10;                System.out.println(&quot;Processing file: &quot; + filePath);&#10;                Path path = Paths.get(filePath);&#10;                Documentation fileDocumentation = generate(path);&#10;&#10;                // Merge documentation from this file into the combined documentation&#10;                mergeDocumentation(combinedDocumentation, fileDocumentation, filePath);&#10;&#10;            } catch (Exception e) {&#10;                System.err.println(&quot;Error processing file &quot; + filePath + &quot;: &quot; + e.getMessage());&#10;                throw new RuntimeException(&quot;Failed to process file: &quot; + filePath, e);&#10;            }&#10;        }&#10;&#10;        return combinedDocumentation;&#10;    }&#10;&#10;    /**&#10;     * Merges documentation from one file into the combined documentation.&#10;     * @param target The target documentation to merge into&#10;     * @param source The source documentation to merge from&#10;     * @param sourceFileName The name of the source file (for error reporting)&#10;     */&#10;    private static void mergeDocumentation(Documentation target, Documentation source, String sourceFileName) {&#10;        // Check for class name conflicts and merge fields&#10;        for (Class sourceClass : source.classes) {&#10;            Class existingClass = findClassByName(target, sourceClass.name);&#10;            if (existingClass != null) {&#10;                // Class already exists - merge fields and functions instead of skipping&#10;                System.out.println(&quot;Merging class '&quot; + sourceClass.name + &quot;' - adding &quot; +&#10;                    sourceClass.fields.size() + &quot; new fields and &quot; + sourceClass.functions.size() + &quot; new functions&quot;);&#10;&#10;                // Add all new fields from source class to existing class&#10;                for (Field newField : sourceClass.fields) {&#10;                    // Check if field already exists&#10;                    boolean fieldExists = false;&#10;                    for (Field existingField : existingClass.fields) {&#10;                        if (existingField.name.equals(newField.name)) {&#10;                            fieldExists = true;&#10;                            break;&#10;                        }&#10;                    }&#10;                    if (!fieldExists) {&#10;                        existingClass.fields.add(newField);&#10;                    }&#10;                }&#10;&#10;                // Add all new functions from source class to existing class&#10;                for (Function newFunction : sourceClass.functions) {&#10;                    // Check if function already exists&#10;                    boolean functionExists = false;&#10;                    for (Function existingFunction : existingClass.functions) {&#10;                        if (existingFunction.name.equals(newFunction.name)) {&#10;                            functionExists = true;&#10;                            break;&#10;                        }&#10;                    }&#10;                    if (!functionExists) {&#10;                        existingClass.functions.add(newFunction);&#10;                    }&#10;                }&#10;&#10;                // Merge parent classes if they don't already exist&#10;                for (String newParent : sourceClass.parent) {&#10;                    if (!existingClass.parent.contains(newParent)) {&#10;                        existingClass.parent.add(newParent);&#10;                    }&#10;                }&#10;            } else {&#10;                // New class - add it normally&#10;                target.addClass(sourceClass);&#10;            }&#10;        }&#10;&#10;        // Add all functions (global functions can have the same name in different contexts)&#10;        for (Function function : source.functions) {&#10;            target.addFunction(function);&#10;        }&#10;&#10;        // Add all variables&#10;        for (Variable variable : source.variables) {&#10;            target.addVariable(variable);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Checks if a function block represents a local function.&#10;     * @param block The doc block to check&#10;     * @return true if this is a local function&#10;     */&#10;    private static boolean isLocalFunction(DocBlock block) {&#10;        // Check if any line in the block contains &quot;local function&quot;&#10;        for (String line : block.lines) {&#10;            if (line.trim().startsWith(&quot;local function&quot;)) {&#10;                return true;&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;&#10;    private static void processStandaloneFields(List&lt;DocBlock&gt; blocks, Documentation documentation) {&#10;        // Verarbeite @field Blöcke die nach Klassendefinitionen stehen&#10;        for (DocBlock block : blocks) {&#10;            // Suche nach @field Blöcken ohne eigene Klassendefinition&#10;            if (!block.fields.isEmpty() &amp;&amp; block.className.isEmpty()) {&#10;                // Analysiere die Code-Zeilen, um die Zielklasse zu bestimmen&#10;                String targetClassName = findTargetClassForFields(block, documentation);&#10;&#10;                if (targetClassName != null) {&#10;                    Class targetClass = findClassByName(documentation, targetClassName);&#10;                    if (targetClass != null) {&#10;                        // Füge alle Felder zur gefundenen Klasse hinzu&#10;                        targetClass.fields.addAll(block.fields);&#10;                    }&#10;                } else {&#10;                    // Wenn keine Zielklasse gefunden wurde, versuche aus den @field Namen zu inferieren&#10;                    for (Field field : block.fields) {&#10;                        // Suche nach einer Klasse basierend auf Code-Zeilen&#10;                        String inferredClassName = inferClassNameFromCodeLines(block, field.name, documentation);&#10;                        if (inferredClassName != null) {&#10;                            Class targetClass = findClassByName(documentation, inferredClassName);&#10;                            if (targetClass != null) {&#10;                                targetClass.fields.add(field);&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private static String findTargetClassForFields(DocBlock fieldBlock, Documentation documentation) {&#10;        // Analysiere die Code-Zeilen im Field-Block, um die Zielklasse zu finden&#10;        for (String line : fieldBlock.lines) {&#10;            String trimmed = line.trim();&#10;            // Suche nach Zuweisungen wie &quot;Config.General.name = ...&quot;&#10;            if (trimmed.matches(&quot;[\\w.]+\\s*=.*&quot;)) {&#10;                Pattern pattern = Pattern.compile(&quot;([\\w.]+)\\.[\\w]+\\s*=&quot;);&#10;                Matcher matcher = pattern.matcher(trimmed);&#10;                if (matcher.find()) {&#10;                    String possibleClassName = matcher.group(1);&#10;                    // Prüfe, ob diese Klasse existiert&#10;                    if (findClassByName(documentation, possibleClassName) != null) {&#10;                        return possibleClassName;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;&#10;    private static String inferClassNameFromCodeLines(DocBlock block, String fieldName, Documentation documentation) {&#10;        // Suche nach Code-Zeilen, die den Feldnamen verwenden&#10;        for (String line : block.lines) {&#10;            String trimmed = line.trim();&#10;            // Pattern für Zuweisungen wie &quot;Config.General.fieldName = ...&quot;&#10;            if (trimmed.contains(fieldName) &amp;&amp; trimmed.contains(&quot;=&quot;)) {&#10;                Pattern pattern = Pattern.compile(&quot;([\\w.]+)\\.&quot; + Pattern.quote(fieldName) + &quot;\\s*=&quot;);&#10;                Matcher matcher = pattern.matcher(trimmed);&#10;                if (matcher.find()) {&#10;                    String possibleClassName = matcher.group(1);&#10;                    // Prüfe, ob diese Klasse existiert&#10;                    if (findClassByName(documentation, possibleClassName) != null) {&#10;                        return possibleClassName;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;        return null;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>